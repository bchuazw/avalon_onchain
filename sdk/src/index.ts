import {
  Connection,
  PublicKey,
  Keypair,
  Transaction,
  SystemProgram,
  LAMPORTS_PER_SOL,
  sendAndConfirmTransaction,
  TransactionInstruction,
} from "@solana/web3.js";
import { BN, Program, AnchorProvider, Wallet } from "@coral-xyz/anchor";
import axios from "axios";
import * as crypto from "crypto";

// ==================== Enums ====================

export enum Role {
  Unknown = 0,
  Merlin = 1,
  Percival = 2,
  Servant = 3,
  Morgana = 4,
  Assassin = 5,
  Minion = 6,
}

export enum Alignment {
  Unknown = 0,
  Good = 1,
  Evil = 2,
}

export enum GamePhase {
  Lobby = 0,
  RoleAssignment = 1,
  TeamBuilding = 2,
  Voting = 3,
  Quest = 4,
  Assassination = 5,
  Ended = 6,
}

// ==================== Types ====================

export interface AgentConfig {
  connection: Connection;
  programId: PublicKey;
  backendUrl: string;
}

export interface RoleInfo {
  role: Role;
  alignment: Alignment;
  knownPlayers: PublicKey[];
  merkleProof: number[][];
}

export interface GameStateInfo {
  gameId: string;
  creator: PublicKey;
  phase: GamePhase;
  playerCount: number;
  currentQuest: number;
  leaderIndex: number;
  successfulQuests: number;
  failedQuests: number;
  winner: Alignment | null;
  players: Array<{
    pubkey: PublicKey;
    role: Role;
    alignment: Alignment;
  } | null>;
  quests: Array<{
    requiredPlayers: number;
    failRequired: number;
    teamSize: number;
    passed: boolean | null;
    voteAttempts: number;
  }>;
}

// ==================== IDL (minimal for client usage) ====================

// We define just enough of the IDL for the client to build transactions.
// The full IDL is generated by `anchor build` at target/idl/avalon_game.json.
const AVALON_IDL = {
  version: "0.1.0",
  name: "avalon_game",
  instructions: [
    { name: "createGame", accounts: ["creator", "gameState", "systemProgram"], args: [{ name: "gameId", type: "u64" }] },
    { name: "joinGame", accounts: ["player", "gameState", "systemProgram"], args: [] },
    { name: "startGame", accounts: ["creator", "gameState"], args: [{ name: "vrfSeed", type: { array: ["u8", 32] } }, { name: "rolesCommitment", type: { array: ["u8", 32] } }] },
    { name: "submitRoleReveal", accounts: ["player", "gameState", "playerRole", "systemProgram"], args: [{ name: "role", type: "u8" }, { name: "alignment", type: "u8" }, { name: "merkleProof", type: { vec: { array: ["u8", 32] } } }] },
    { name: "proposeTeam", accounts: ["player", "gameState"], args: [{ name: "team", type: { vec: "publicKey" } }] },
    { name: "voteTeam", accounts: ["player", "gameState"], args: [{ name: "approve", type: "bool" }] },
    { name: "submitQuestVote", accounts: ["player", "gameState", "playerRole"], args: [{ name: "success", type: "bool" }] },
    { name: "assassinGuess", accounts: ["assassin", "gameState"], args: [{ name: "target", type: "publicKey" }] },
    { name: "advancePhase", accounts: ["caller", "gameState"], args: [] },
  ],
} as const;

// ==================== Helper: PDA derivation ====================

function deriveGamePDA(gameId: BN, programId: PublicKey): [PublicKey, number] {
  return PublicKey.findProgramAddressSync(
    [Buffer.from("game"), gameId.toArrayLike(Buffer, "le", 8)],
    programId
  );
}

function derivePlayerRolePDA(
  gamePDA: PublicKey,
  player: PublicKey,
  programId: PublicKey
): [PublicKey, number] {
  return PublicKey.findProgramAddressSync(
    [Buffer.from("player_role"), gamePDA.toBuffer(), player.toBuffer()],
    programId
  );
}

// ==================== AvalonAgent ====================

/**
 * AvalonAgent - SDK for AI agents to interact with the Avalon on Solana game.
 *
 * Usage:
 *   const keypair = AvalonAgent.createWallet();
 *   const agent = new AvalonAgent(keypair, { connection, programId, backendUrl });
 *   await agent.fundWallet(2 * LAMPORTS_PER_SOL);
 *   const { gamePDA, signature } = await agent.createGame(gameId);
 */
export default class AvalonAgent {
  private keypair: Keypair;
  private config: AgentConfig;
  private provider: AnchorProvider;
  private _roleInfo: RoleInfo | null = null;

  constructor(keypair: Keypair, config: AgentConfig) {
    this.keypair = keypair;
    this.config = config;

    // Create an AnchorProvider for this agent
    const wallet = new Wallet(keypair);
    this.provider = new AnchorProvider(config.connection, wallet, {
      commitment: "confirmed",
      preflightCommitment: "confirmed",
    });
  }

  // ---- Static helpers ----

  static createWallet(): Keypair {
    return Keypair.generate();
  }

  // ---- Properties ----

  get publicKey(): PublicKey {
    return this.keypair.publicKey;
  }

  get isGood(): boolean {
    if (!this._roleInfo) return true; // default to good if unknown
    return this._roleInfo.alignment === Alignment.Good;
  }

  get role(): Role {
    return this._roleInfo?.role ?? Role.Unknown;
  }

  get alignment(): Alignment {
    return this._roleInfo?.alignment ?? Alignment.Unknown;
  }

  // ---- Wallet ----

  async getBalance(): Promise<number> {
    return this.config.connection.getBalance(this.publicKey);
  }

  async fundWallet(lamports: number): Promise<string> {
    const sig = await this.config.connection.requestAirdrop(
      this.publicKey,
      lamports
    );
    await this.config.connection.confirmTransaction(sig, "confirmed");
    return sig;
  }

  // ---- Game lifecycle ----

  async createGame(
    gameId: BN
  ): Promise<{ gamePDA: PublicKey; signature: string }> {
    const [gamePDA] = deriveGamePDA(gameId, this.config.programId);

    // Build the create_game instruction manually (no full IDL dependency)
    const ix = await this.buildInstruction("createGame", {
      gameId,
      accounts: {
        creator: this.publicKey,
        gameState: gamePDA,
        systemProgram: SystemProgram.programId,
      },
    });

    const tx = new Transaction().add(ix);
    const signature = await sendAndConfirmTransaction(
      this.config.connection,
      tx,
      [this.keypair],
      { commitment: "confirmed" }
    );

    return { gamePDA, signature };
  }

  async joinGame(gamePDA: PublicKey): Promise<string> {
    const ix = await this.buildInstruction("joinGame", {
      accounts: {
        player: this.publicKey,
        gameState: gamePDA,
        systemProgram: SystemProgram.programId,
      },
    });

    const tx = new Transaction().add(ix);
    return sendAndConfirmTransaction(
      this.config.connection,
      tx,
      [this.keypair],
      { commitment: "confirmed" }
    );
  }

  async startGame(
    gamePDA: PublicKey,
    vrfSeed: Buffer,
    rolesCommitment: Buffer
  ): Promise<string> {
    const ix = await this.buildInstruction("startGame", {
      vrfSeed: Array.from(vrfSeed),
      rolesCommitment: Array.from(rolesCommitment),
      accounts: {
        creator: this.publicKey,
        gameState: gamePDA,
      },
    });

    const tx = new Transaction().add(ix);
    return sendAndConfirmTransaction(
      this.config.connection,
      tx,
      [this.keypair],
      { commitment: "confirmed" }
    );
  }

  async submitRoleReveal(gamePDA: PublicKey): Promise<string> {
    if (!this._roleInfo) {
      throw new Error("Must fetch role before submitting reveal");
    }

    const [playerRolePDA] = derivePlayerRolePDA(
      gamePDA,
      this.publicKey,
      this.config.programId
    );

    const ix = await this.buildInstruction("submitRoleReveal", {
      role: this._roleInfo.role,
      alignment: this._roleInfo.alignment,
      merkleProof: this._roleInfo.merkleProof,
      accounts: {
        player: this.publicKey,
        gameState: gamePDA,
        playerRole: playerRolePDA,
        systemProgram: SystemProgram.programId,
      },
    });

    const tx = new Transaction().add(ix);
    return sendAndConfirmTransaction(
      this.config.connection,
      tx,
      [this.keypair],
      { commitment: "confirmed" }
    );
  }

  async proposeTeam(gamePDA: PublicKey, team: PublicKey[]): Promise<string> {
    const ix = await this.buildInstruction("proposeTeam", {
      team,
      accounts: {
        player: this.publicKey,
        gameState: gamePDA,
      },
    });

    const tx = new Transaction().add(ix);
    return sendAndConfirmTransaction(
      this.config.connection,
      tx,
      [this.keypair],
      { commitment: "confirmed" }
    );
  }

  async voteTeam(gamePDA: PublicKey, approve: boolean): Promise<string> {
    const ix = await this.buildInstruction("voteTeam", {
      approve,
      accounts: {
        player: this.publicKey,
        gameState: gamePDA,
      },
    });

    const tx = new Transaction().add(ix);
    return sendAndConfirmTransaction(
      this.config.connection,
      tx,
      [this.keypair],
      { commitment: "confirmed" }
    );
  }

  async submitQuestVote(
    gamePDA: PublicKey,
    success: boolean
  ): Promise<string> {
    const [playerRolePDA] = derivePlayerRolePDA(
      gamePDA,
      this.publicKey,
      this.config.programId
    );

    const ix = await this.buildInstruction("submitQuestVote", {
      success,
      accounts: {
        player: this.publicKey,
        gameState: gamePDA,
        playerRole: playerRolePDA,
      },
    });

    const tx = new Transaction().add(ix);
    return sendAndConfirmTransaction(
      this.config.connection,
      tx,
      [this.keypair],
      { commitment: "confirmed" }
    );
  }

  async assassinGuess(gamePDA: PublicKey, target: PublicKey): Promise<string> {
    const ix = await this.buildInstruction("assassinGuess", {
      target,
      accounts: {
        assassin: this.publicKey,
        gameState: gamePDA,
      },
    });

    const tx = new Transaction().add(ix);
    return sendAndConfirmTransaction(
      this.config.connection,
      tx,
      [this.keypair],
      { commitment: "confirmed" }
    );
  }

  async advancePhase(gamePDA: PublicKey): Promise<string> {
    const ix = await this.buildInstruction("advancePhase", {
      accounts: {
        caller: this.publicKey,
        gameState: gamePDA,
      },
    });

    const tx = new Transaction().add(ix);
    return sendAndConfirmTransaction(
      this.config.connection,
      tx,
      [this.keypair],
      { commitment: "confirmed" }
    );
  }

  // ---- State queries ----

  async getGameState(gamePDA: PublicKey): Promise<GameStateInfo> {
    const accountInfo = await this.config.connection.getAccountInfo(gamePDA);
    if (!accountInfo) {
      throw new Error("Game account not found");
    }

    // Decode the account data using the Anchor discriminator + layout.
    // For a cleaner decode, we'd use the full IDL with Program.account.gameState.fetch().
    // Here we use a simpler approach via the backend's indexer.
    try {
      const response = await axios.get(
        `${this.config.backendUrl}/game/${gamePDA.toBase58()}`
      );
      return response.data;
    } catch {
      // Fallback: return minimal info from raw account
      return {
        gameId: "unknown",
        creator: PublicKey.default,
        phase: GamePhase.Lobby,
        playerCount: 0,
        currentQuest: 0,
        leaderIndex: 0,
        successfulQuests: 0,
        failedQuests: 0,
        winner: null,
        players: [],
        quests: [],
      };
    }
  }

  // ---- Role management ----

  async fetchRole(gameId: string): Promise<RoleInfo> {
    // Sign a challenge to prove identity
    const timestamp = Date.now().toString();
    const message = Buffer.from(`avalon-role-request:${gameId}:${timestamp}`);
    const signature = crypto
      .createHash("sha256")
      .update(Buffer.concat([message, this.keypair.secretKey.slice(0, 32)]))
      .digest("hex");

    const response = await axios.post(
      `${this.config.backendUrl}/role-inbox/${gameId}`,
      {
        playerPubkey: this.publicKey.toBase58(),
        timestamp,
        signature,
      }
    );

    this._roleInfo = {
      role: response.data.role as Role,
      alignment: response.data.alignment as Alignment,
      knownPlayers: (response.data.knownPlayers || []).map(
        (pk: string) => new PublicKey(pk)
      ),
      merkleProof: response.data.merkleProof || [],
    };

    return this._roleInfo;
  }

  // ---- Internal: instruction builder ----

  /**
   * Builds a transaction instruction for the Avalon program.
   * Uses Anchor's discriminator (first 8 bytes of sha256("global:<instruction_name>"))
   * to construct the instruction data, then manually serialises arguments.
   */
  private async buildInstruction(
    instructionName: string,
    params: Record<string, any>
  ): Promise<TransactionInstruction> {
    const { accounts, ...args } = params;

    // Compute Anchor instruction discriminator
    const discriminator = this.computeDiscriminator(instructionName);

    // Serialize arguments
    const argsData = this.serializeArgs(instructionName, args);

    // Combine discriminator + args
    const data = Buffer.concat([discriminator, argsData]);

    // Build account keys from the accounts map
    const accountKeys = this.buildAccountKeys(instructionName, accounts);

    return new TransactionInstruction({
      keys: accountKeys,
      programId: this.config.programId,
      data,
    });
  }

  private computeDiscriminator(instructionName: string): Buffer {
    // Anchor uses snake_case for the discriminator hash
    const snakeName = instructionName.replace(
      /[A-Z]/g,
      (c) => `_${c.toLowerCase()}`
    );
    const hash = crypto
      .createHash("sha256")
      .update(`global:${snakeName}`)
      .digest();
    return hash.slice(0, 8);
  }

  private serializeArgs(
    instructionName: string,
    args: Record<string, any>
  ): Buffer {
    const buffers: Buffer[] = [];

    switch (instructionName) {
      case "createGame": {
        // u64 game_id
        const gameId = args.gameId as BN;
        buffers.push(gameId.toArrayLike(Buffer, "le", 8));
        break;
      }
      case "startGame": {
        // [u8; 32] vrf_seed
        buffers.push(Buffer.from(args.vrfSeed));
        // [u8; 32] roles_commitment
        buffers.push(Buffer.from(args.rolesCommitment));
        break;
      }
      case "submitRoleReveal": {
        // u8 role (as enum variant)
        buffers.push(Buffer.from([args.role]));
        // u8 alignment (as enum variant)
        buffers.push(Buffer.from([args.alignment]));
        // Vec<[u8; 32]> merkle_proof
        const proof = args.merkleProof as number[][];
        // Vec length prefix (4 bytes LE)
        const lenBuf = Buffer.alloc(4);
        lenBuf.writeUInt32LE(proof.length, 0);
        buffers.push(lenBuf);
        for (const p of proof) {
          buffers.push(Buffer.from(p));
        }
        break;
      }
      case "proposeTeam": {
        // Vec<Pubkey> team
        const team = args.team as PublicKey[];
        const teamLenBuf = Buffer.alloc(4);
        teamLenBuf.writeUInt32LE(team.length, 0);
        buffers.push(teamLenBuf);
        for (const pk of team) {
          buffers.push(pk.toBuffer());
        }
        break;
      }
      case "voteTeam": {
        // bool approve
        buffers.push(Buffer.from([args.approve ? 1 : 0]));
        break;
      }
      case "submitQuestVote": {
        // bool success
        buffers.push(Buffer.from([args.success ? 1 : 0]));
        break;
      }
      case "assassinGuess": {
        // Pubkey target
        buffers.push((args.target as PublicKey).toBuffer());
        break;
      }
      case "joinGame":
      case "advancePhase":
        // No args
        break;
      default:
        throw new Error(`Unknown instruction: ${instructionName}`);
    }

    return Buffer.concat(buffers);
  }

  private buildAccountKeys(
    instructionName: string,
    accounts: Record<string, PublicKey>
  ): Array<{ pubkey: PublicKey; isSigner: boolean; isWritable: boolean }> {
    // Map instruction names to their expected account layout
    // Order must match the Anchor #[derive(Accounts)] struct field order
    const layouts: Record<string, Array<{ name: string; isSigner: boolean; isWritable: boolean }>> = {
      createGame: [
        { name: "creator", isSigner: true, isWritable: true },
        { name: "gameState", isSigner: false, isWritable: true },
        { name: "systemProgram", isSigner: false, isWritable: false },
      ],
      joinGame: [
        { name: "player", isSigner: true, isWritable: true },
        { name: "gameState", isSigner: false, isWritable: true },
        { name: "systemProgram", isSigner: false, isWritable: false },
      ],
      startGame: [
        { name: "creator", isSigner: true, isWritable: true },
        { name: "gameState", isSigner: false, isWritable: true },
      ],
      submitRoleReveal: [
        { name: "player", isSigner: true, isWritable: true },
        { name: "gameState", isSigner: false, isWritable: true },
        { name: "playerRole", isSigner: false, isWritable: true },
        { name: "systemProgram", isSigner: false, isWritable: false },
      ],
      proposeTeam: [
        { name: "player", isSigner: true, isWritable: true },
        { name: "gameState", isSigner: false, isWritable: true },
      ],
      voteTeam: [
        { name: "player", isSigner: true, isWritable: true },
        { name: "gameState", isSigner: false, isWritable: true },
      ],
      submitQuestVote: [
        { name: "player", isSigner: true, isWritable: true },
        { name: "gameState", isSigner: false, isWritable: true },
        { name: "playerRole", isSigner: false, isWritable: false },
      ],
      assassinGuess: [
        { name: "assassin", isSigner: true, isWritable: true },
        { name: "gameState", isSigner: false, isWritable: true },
      ],
      advancePhase: [
        { name: "caller", isSigner: true, isWritable: true },
        { name: "gameState", isSigner: false, isWritable: true },
      ],
    };

    const layout = layouts[instructionName];
    if (!layout) throw new Error(`No account layout for: ${instructionName}`);

    return layout.map((acc) => ({
      pubkey: accounts[acc.name],
      isSigner: acc.isSigner,
      isWritable: acc.isWritable,
    }));
  }
}
